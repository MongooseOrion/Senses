# 硬件与软件的边缘开发

汇编语言是比较接近硬件的层次，学习它对认识硬件至关重要。

## 本页内容

  * 指令的寻址方式
  * FreeRTOS 在硬件上部署

### 指令的寻址方式

#### 寄存器寻址

寄存器寻址就是直接以通用寄存器作为操作数。例如：

```
MOV A,R0
```
上述语句表明了将通用寄存器 `R0` 中的内容传送给累加器寄存器 `A`。

#### 直接寻址

直接寻址就是在指令中直接给出操作数的地址。例如：

```
MOV A,3AH
```

其中，`3AH` 是直接地址，表示内部 RAM 的 `3A` 单元，`H` 表示 16 进制。该语句表示将 `3A` 单元中的数据传送给 `A`。

#### 立即寻址

如果指令的操作数是一个 8 位二进制数或 16 位二进制数，就称为立即寻址。例如：

```
MOV A,#3AH
```
其中，井号是为了与直接寻址进行区分，一个是操作地址，一个是直接操作数。例如在直接寻址中，假设 `3A` 地址中存放的是数 `6BH`，则 A=6B；而在立即寻址中，A=3A。

#### 寄存器间接寻址

如果寄存器中存放的是操作数的地址，那么叫做寄存器间接寻址，如果是这种寻址方式，会在寄存器前加 `@`。例如：

```
        MOV R7,#20      // 将立即数 2'b20 送到通用寄存器 R7
        MOV R0,#30H     // 将立即数 2'h30 送到通用寄存器 R0
LOOP:   MOV A,@R0       // 取出 R0 的值，把这个值作为地址，然后把这个地址单元的内容送入 A，该指令等价于直接寻址指令：MOV A,30H
        INC R0          // 把 R0 中的值加一
        DJNZ R7,LOOP    // 将 R7 的值减一，然后判断值是否等于 0，如果不等于 0，则跳转到 LOOP 处执行，并继续执行后续的指令，直到 R7 减一操作减到 0
```

上述代码实现了一个从地址 30H 开始取 20 个地址单元内的数值（30H, 31H,...,44H），并分别送入 `A` 中的功能。

#### 变址寻址

变址寻址是以某个寄存器的内容为基本地址，然后在这个地址的基础上加一个地址偏移量，得到最终的操作数地址。这个地址单元的内容作为最终的操作数。例如：

```
MOVC A,@A+DPTR
```

其中，`DPTR` 为数据指针，基本地址也可以用程序计数器 PC 表示。如果假设 `A=54H`、`DPTR=3F21H`，则操作数的地址应该是 `4'h3F21+2'h54=4'h3F75`。所以该指令执行后，会将程序存储器 `3F75` 单元中的内容传送给 `A`。

